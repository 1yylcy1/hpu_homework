/*************************************************************
    图的广度优先遍历  实现文件
    更新于2020年6月17日
**************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ALGraph.h"

int visited[MAXVEX]; /*设访问标志数组为全局变量*/

void BFSTraverse(ALGraph  g) 
{/*广度优先遍历以邻接表存储的图g，由于BFS要求”先被访问的顶点的邻接点也先被访问”，故需借助队列Q实现*/
	// 请在这里补充代码，完成本关任务
    /********** Begin *********/
    void InitQueue(SeqQueue &q);
    int QueueEmpty(SeqQueue q);
    void EnQueue(SeqQueue &q, datatype x);
    void DeQueue(SeqQueue &q, datatype &x);
    ENode *w;
   	int v=0;
    printf("%d ", v);
    visited[v]=true;
    SeqQueue q;
    InitQueue(q);
    EnQueue(q,v);
    while(!QueueEmpty(q)){
        DeQueue(q,v);
        w=g.vertices[v].firstarc;
        while(w){
            if(!visited[w->adjvex]){
                printf("%d ",w->adjvex);
                visited[w->adjvex]=true;
                EnQueue(q,w->adjvex);
            }
            w=w->nextarc;
        }
    }
    /********** End **********/		
}  

void InitQueue(SeqQueue &q)//队列的初始化
{
	q.front=q.rear=0;q.len=0;
}
int QueueEmpty(SeqQueue q)//判队空
{
	if(q.len==0)return 1;
	else return 0; 
}
void EnQueue(SeqQueue &q, datatype x)//将元素x入队
{
	if(q.len==MAXSIZE)//判队满
	{
		printf("Queue is full\n");return;
	}
	q.data[q.rear]=x; q.rear=(q.rear+1)%MAXSIZE;
	q.len++;
}
void DeQueue(SeqQueue &q, datatype &x)//将队头元素出队
{
	if(q.len==0)//判队空
	{
		printf("Queue is empty\n");return;
	}
	x=q.data[q.front]; q.front=(q.front+1)%MAXSIZE;
	q.len--;
}

void CreateUDG_ALG(ALGraph &g) /*构造无向图的邻接表*/
{
	
	int i,j,k;ENode *p;
	//printf("请输入图的类型(0-3表示DG,DN,UDG,UDN)、顶点数、边数：\n");
	scanf("%d%d%d",&g.kind,&g.vexnum,&g.edgenum);
	for(i=0;i<g.vexnum;i++) /*构造头结点数组*/
	{
		g.vertices[i].vex=i;
		g.vertices[i].firstarc=NULL; /*初始化头结点指针域为空*/
	}
	//printf("请按顶点编号从小到大的顺序输入各条边的两顶点：\n");
	for(k=0;k<g.edgenum;k++) /*构造邻接表*/
	{
		scanf("%d%d",&i,&j); /*输入一条边所依附的两个顶点的编号*/
		/*将顶点Vj插入到第i个单链表的表头，也就是用“头插法”建立一个单链表*/
		p=(ENode *)malloc(sizeof(ENode)); /*生成表结点*/
		p->adjvex=j; p->weight=0;
		p->nextarc=g.vertices[i].firstarc; /*插入表结点*/
		g.vertices[i].firstarc=p;
		/*将顶点Vi插入到第j个单链表的表头，也就是用“头插法”建立一个单链表*/
		p=(ENode *)malloc(sizeof(ENode));
		p->adjvex=i; p->weight=0;
		p->nextarc=g.vertices[j].firstarc;
		g.vertices[j].firstarc=p;
	}
}